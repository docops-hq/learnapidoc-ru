# Знакомство со спецификациями OpenAPI и Swagger

[OpenAPI](https://www.openapis.org/) является спецификацией для описания REST API. Можно рассматривать спецификацию OpenAPI как спецификацию DITA. В DITA существуют определенные элементы XML, используемые для определения компонентов справки, а также требуемый порядок и иерархия для этих элементов. Различные инструменты могут читать DITA и создавать веб-сайт документации на основе информации.

В OpenAPI вместо XML существует набор объектов JSON с определенной схемой, которая определяет их наименование, порядок и содержимое. Этот файл JSON (часто выражается в YAML вместо JSON) описывает каждую часть API. Описывая API в стандартном формате, инструменты публикации могут программно анализировать информацию об API и отображать каждый компонент в стилизованном интерактивном виде.

> Если есть желание сразу перейти к пошаговому справочнику по созданию документации в спецификации OpenAPI, см. [Обзор руководства OpenAPI](https://github.com/Starkovden/Documenting_APIs/blob/master/4.%20OpenAPI%20specification%20and%20Swagger/4.4.%20OpenAPI%20tutorial%20overview.md).

[Взгляд на спецификацию OpenAPI](#glancing)

[Проверка спецификации](#validating)

[Автоматическая генерация файла OpenAPI из аннотаций кода](#fileGenerate)

[Подход: разработка по спецификации](#specFirst)

[Роль технического писателя в спецификации](#role)

[Визуализация спецификации OpenAPI с помощью Swagger UI](#rendering)

[Практическое занятие: Исследуем API PetStore в Swagger UI](#petStore)

[Другие инструменты визуализации](#otherTools)

[Кастомизация Swagger UI](#customize)

[Недостатки OpenAPI и Swagger UI](#downsides)

[Некоторые утешения](#consolations)

[Ресурсы для дальнейшего чтения](#reading)

<a name="glancing"></a>
## Взгляд на спецификацию OpenAPI

Чтобы лучше понять спецификацию OpenAPI, давайте взглянем на некоторые выдержки из спецификации. Углубимся в каждый элемент в следующих разделах.

Официальное описание спецификации OpenAPI доступно в [репозитории Github](https://github.com/OAI/OpenAPI-Specification). Элементы OpenAPI - это `paths`, `parameters`, `responses` и `security`. Каждый из этих элементов является объектом JSON, который содержит свойства и массивы.

В спецификации OpenAPI ваши конечные точки это `paths`. Конечная точка `/pet`, в спецификации OpenAPI может выглядеть следующим образом:

    paths:
        /pets:
            get:
                summary: List all pets
                operationId: listPets
                tags:
                    - pets
                parameters:
                    - name: limit
                    in: query
                    description: How many items to return at one time (max 100)
                    required: false
                    schema:
                        type: integer
                        format: int32
                responses:
                    '200':
                    description: An paged array of pets
                    headers:
                        x-next:
                            description: A link to the next page of responses
                            schema:
                                type: string
                    content:
                        application/json:    
                            schema:
                                $ref: "#/components/schemas/Pets"
                default:
                    description: unexpected error
                    content:
                        application/json:
                            schema:
                                $ref: "#/components/schemas/Error"

Это формат YAML, взят из [Swagger PetStore](http://petstore.swagger.io/)

Вот что значат объекты в этом коде:

- `/pets` - конечна точка path;
- `get` - HTTP метод;
- `parameters` - список параметров конечной точки;
- `responses` - список ответов на запрос
- `200` - HTTP код статуса
- `$ref` является ссылкой на другую часть реализации, где определяется ответ (в `components`). OpenAPI имеет много `$ref` ссылок, подобных этой, чтобы сохранить код в чистоте и облегчить его повторное использование.

> Может потребоваться некоторое время, чтобы понять спецификацию OpenAPI. Возьмем пару недель и несколько примеров спецификации, чтобы посмотреть, особенно в контексте фактического API. Спецификация OpenAPI достаточно общая, чтобы описать почти каждый API REST, поэтому некоторые части могут быть более применимыми, чем другие.

<a name="validating"></a>
## Проверка спецификации

При создании спецификации OpenAPI, вместо того, чтобы работать в текстовом редакторе, можно написать свой код в [редакторе Swagger](http://editor.swagger.io/). Редактор Swagger динамически проверяет контент, чтобы определить, является ли созданная  спецификация валидной.

![swagger display](https://github.com/Starkovden/Documenting_APIs/blob/master/4.%20OpenAPI%20specification%20and%20Swagger/img/1.png?raw=true)

Если допустить ошибку при написании кода в редакторе Swagger, можно быстро исправить ее, прежде чем продолжить, вместо того, чтобы ждать запуска сборки и устранять ошибки.

Для формата спецификации у нас есть выбор работы JSON или YAML. Пример кода выше находится в [YAML](https://yaml.org/). У YAML официальное определение: «YAML не является языком разметки», что означает, что в YAML нет тегов разметки (<>), как в других языках разметки, таких как XML.

YAML зависим от пробелов и двоеточий, устанавливающих синтаксис объекта. Такое пространственно-чувствительное форматирование делает код более понятным для человек. Однако, иногда могут возникнуть сложности с расстановкой правильных интервалов.

<a name="fileGenerate"></a>
## Автоматическая генерация файла OpenAPI из аннотаций кода

Вместо того, чтобы кодировать документ в спецификации OpenAPI вручную, также можно автоматически сгенерировать его из аннотаций в программном коде. Этот подход, ориентированный на разработчиков, имеет смысл, если есть большое количество API-интерфейсов или если для технических писателей нецелесообразно создавать эту документацию.

Swagger предлагает множество библиотек, которые можно добавлять в свой программный код для создания документа в спецификации. Эти библиотеки Swagger анализируют аннотации, которые добавляют разработчики, и генерируют документ в спецификации OpenAPI. Эти библиотеки считаются частью проекта [Swagger Codegen](https://swagger.io/tools/swagger-codegen/). Методы аннотации различаются в зависимости от языка программирования. Например, вот [справочник по аннотированию кода с помощью Swagger для Scalatra](https://www.infoq.com/articles/swagger-scalatra). Для получения дополнительной информации о Codegen см. [Сравнение инструментов автоматического генерирования кода API для Swagger](https://apievangelist.com/2015/06/06/comparison-of-automatic-api-code-generation-tools-for-swagger/) по API Evangelist. Дополнительные инструменты и библиотеки см. В разделах [«Интеграции и инструменты Swagger»](https://swagger.io/tools/open-source/open-source-integrations/) и [«Интеграция с открытым исходным кодом»](https://swagger.io/tools/open-source/open-source-integrations/).

Хотя этот подход и «автоматизирует» генерацию спецификации, нужно еще понимать, какие аннотации добавить и как их добавить (этот процесс не слишком отличается от комментариев и аннотаций Javadoc). Затем нужно написать контент для каждого из значений аннотации (описывая конечную точку, параметры и т. Д.).

Короче говоря, поработать все нужно - автоматизированная часть заставляет библиотеки Codegen генерировать определения модели и действительный документ, который соответствует схеме OpenAPI. Тем не менее, многие разработчики взволнованы этим подходом, потому что он предлагает способ генерировать документацию из аннотаций кода, что разработчики годами делали с другими языками программирования, такими как Java (используя [Javadoc](https://www.oracle.com/technetwork/articles/java/index-137868.html)) или C ++ (используя [Doxygen](http://www.doxygen.nl/)). Они обычно считают, что генерация документации из кода приводит к меньшему отклонению документации. Документы, будут оставаться актуальными, если будут тесно связан с кодом.

Если идти по этому пути, нужно убедиться, что есть доступ к исходному коду для внесения изменений в аннотации. В противном случае разработчики будут писать документацию (что может и хорошо, но часто приводит к плохим результатам).

<a name="specFirst"></a>
## Подход: разработка по спецификации

Можно сгенерировать свою спецификацию из аннотаций кода, но говорят, что автоматическая генерация - не лучший подход. [Майкл Стоу (Michael Stowe)](https://twitter.com/mikegstowe) в статье [Беспрепятственный REST: руководство по проектированию Perfect API](https://www.mulesoft.com/lp/ebook/api/restbook) рекомендует группам вручную реализовать спецификацию, а затем обрабатывать документ спецификации как документ, который разработчики используют при выполнении реального кодирования. Этот подход часто упоминается как «spec-first development».

![Беспрепятственный REST](https://github.com/Starkovden/Documenting_APIs/blob/master/4.%20OpenAPI%20specification%20and%20Swagger/img/2.jpg?raw=true)

*Spec-first development это философия о том, как разрабатывать API более эффективно. Если вы следуете философии «сначала спецификация», вы сначала пишете спецификацию и используете ее в качестве контракта, к которому разработчики пишут код.*

Другими словами, разработчики обращаются к спецификации, чтобы увидеть, как должны называться имена параметров, каковы должны быть ответы и так далее. После того, как этот «контракт» или «план» был принят, Стоу говорит, можно поместить аннотации в свой код (при желании), чтобы сгенерировать документ спецификации более автоматизированным способом. Но не стоит кодировать без предварительной спецификации.

Слишком часто команды разработчиков быстро переходят к кодированию конечных точек API, параметров и ответов, без пользовательского тестирования или исследования, соответствует ли API тому, что хотят пользователи. Поскольку управление  версиями API-интерфейсов чрезвычайно сложно (необходимо поддерживать каждую новую версию в дальнейшем с полной обратной совместимостью с предыдущими версиями), есть желание избежать подхода «быстрый сбой», который так часто отмечают agile энтузиасты. Нет ничего хуже, чем выпустить новую версию вашего API, которая делает недействительными конечные точки или параметры, используемые в предыдущих выпусках. Постоянное версионирование в API может стать кошмаром документации.

Компания [Smartbear](https://smartbear.com/), которая делает [SwaggerHub](https://github.com/Starkovden/Documenting_APIs/blob/master/4.%20OpenAPI%20specification%20and%20Swagger/4.16.%20SwaggerHub%20introduction%20and%20tutorial.md) (платформу для совместной работы команд над спецификациями API Swagger), говорит, что теперь для команд чаще встречается ручное написание спецификации, а не встраивание аннотаций исходного кода в программный код для автоматической генерации. Подход “spec-first development” в первую очередь помогает работать документации среди большего количества членов команды, нежели только инженеров. Определение спецификации перед кодированием также помогает командам создавать лучшие API.

Даже до создания API спецификация может генерировать [ложный ответ](), добавляя определения ответа в спецификацию. Мок-сервер генерирует ответ, который выглядит так, как будто он исходит от реального сервера, но это просто предопределенный ответ в коде, и кажется динамичным для пользователя.

<a name="role"></a>
## Роль технического писателя в спецификации

В большинстве проектов Тома Джонсона разработчики были не очень хорошо знакомы с Swagger или OpenAPI, поэтому он обычно создавал документ спецификации OpenAPI вручную. Кроме того, он часто не имел доступа к исходному коду, и для разработчиков английский язык был не родным. Документация была для них сложным делом.

Возможно, и нам будут попадаться инженеры, не знакомые с Swagger или OpenAPI, но заинтересованные в использовании их в качестве подхода к документации API (подход, основанный на схемах, соответствует инженерному мышлению). Таким образом, нам, вероятно, придется взять на себя инициативу, чтобы направлять инженеров к необходимой информации, подходу и другим деталям, которые соответствуют лучшим практикам для создания спецификации.

В этом отношении технические писатели играют ключевую роль в сотрудничестве с командой в разработке спецификации API. Если придерживаться философии разработки, основанной на спецификациях, эта роль (техписателя) может помочь сформировать API до его кодирования и блокировки. Это означает, что может быть возможность влиять на имена конечных точек, консистенцию и шаблоны, простоту и другие факторы, которые влияют на разработку API (на которые, обычно, не влияют технические писатели).

<a name="rendering"></a>
## Визуализация спецификации OpenAPI с помощью Swagger UI

После того, как получился действующий документ по спецификации OpenAPI, описывающий API, можно "скормить" эту спецификацию различным инструментам, чтобы проанализировать ее и сгенерировать интерактивную документацию, аналогичную [примеру Petstore](http://petstore.swagger.io/).

Наиболее распространенным инструментом, используемым для анализа спецификации OpenAPI, является [Swagger UI](https://github.com/swagger-api/swagger-ui). (Помните, что «Swagger» относится к инструментам API, тогда как «OpenAPI» относится к независимой от поставщика спецификации, не зависящей от инструмента.) После загрузки пользовательского интерфейса Swagger его довольно легко настроить с помощью собственного файла спецификации. Руководство по настройке Swagger UI [есть в этом модуле](https://github.com/Starkovden/Documenting_APIs/blob/master/4.%20OpenAPI%20specification%20and%20Swagger/4.14.%20Swagger%20UI%20tutorial.md).


Код пользовательского интерфейса Swagger генерирует экран, который выглядит следующим образом:

![display](https://github.com/Starkovden/Documenting_APIs/blob/master/4.%20OpenAPI%20specification%20and%20Swagger/img/3.png?raw=true)

> На изображении видно, как Swagger отображает спецификацию Open API


Можно ознакомиться с [примером интеграции Swagger UI с примером API сервиса погоды](https://idratherbewriting.com/learnapidoc/assets/files/swagger/), использованным в качестве примера курса.

Некоторые дизайнеры критикуют выпадающие списки Swagger UI как устаревшие. В то же время разработчики считают одностраничную модель привлекательной и способной уменьшать или увеличивать детали. Объединяя все конечные точки на одной странице в одном представлении, пользователи могут сразу увидеть весь API. Такое отображение дает пользователям представление в целом, что помогает уменьшить сложность и позволяет им начать. Во многих отношениях отображение Swagger UI является [кратким справочным руководством по API](https://github.com/Starkovden/Documenting_APIs/blob/master/6.%20Non-reference%20API%20topics/6.9.%20Quick%20reference%20guide.md).

<a name="petStore"></a>
## ![idea](https://github.com/Starkovden/Documenting_APIs/blob/master/1.%20Introduction%20to%20REST%20APIs/pics/1.jpg?raw=true) Практическое занятие: Исследуем API PetStore в Swagger UI

Давайте познакомимся с пользовательским интерфейсом Swagger, используя Petstore.

1. Переходим по ссылке [Swagger Pet Store Demo](https://petstore.swagger.io)

Как и в большинстве основанных на Swagger'е инструментов, в интерфейсе Swagger есть кнопка «Try it out». Для работы необходима авторизация в Swagger. Авторизация по нажатии на  кнопку `Authorize`, в появившемся окне нужно вставить корректную информацию. При желании авторизоваться можно добавив любой номер в поле `api_key` и нажав `Authorize`. Окно авторизации Petstore предназначено только для демонстрации, так что окно можно просто закрыть.

![auth](https://github.com/Starkovden/Documenting_APIs/blob/master/1.%20Introduction%20to%20REST%20APIs/pics/10.png?raw=true)
*Окно авторизации в Swagger UI*

2. Разверните конечную точку **Pet**

3. Нажимаем на кнопку `Try it out`. После нажатие пример значения в поле "Тело запроса" станет редактируемым.

![Try_it_out](https://github.com/Starkovden/Documenting_APIs/blob/master/1.%20Introduction%20to%20REST%20APIs/pics/11.png?raw=true)

*Кнопка `Try it out` в Swagger UI*

4. В примере заменяем значение `id` на другое целое (не повторяющееся) число.
 Далее меняем значение `value` на какое-нибудь узнаваемое (имя щенка - `Puppy`).

5. Нажимаем  `Execute`

![Execute](https://github.com/Starkovden/Documenting_APIs/blob/master/1.%20Introduction%20to%20REST%20APIs/pics/12.png?raw=true)

*Выполнение примера Petstore запроса*

Swagger UI отправляет запрос и показывает отправленный curl.
В примере был отправлен curl:

	curl -X POST "https://petstore.swagger.io/v2/pet" -H "accept: application/xml" -H "Content-Type: application/json" -d "{ \"id\": 1000, \"category\": { \"id\": 0, \"name\": \"string\" }, \"name\": \"Bentley\", \"photoUrls\": [ \"string\" ], \"tags\": [ { \"id\": 0, \"name\": \"string\" } ], \"status\": \"available\"}"

Обратите внимание, что с параметром -d (data) параметр тела запроса экранируется и добавляется непосредственно в команду curl, а не загружается из файла (как описано в [Common curl commands related to REST]()).

В разделе "Ответы" Swagger UI выдает ответ сервера. По умолчанию ответ возвращает XML:

	<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		<Pet>
			<category>
				<id>0</id>
				<name>string</name>
			</category>
			<id>1000</id>
			<name>Bentley</name>
			<photoUrls>
				<photoUrl>string</photoUrl>
			</photoUrls>
			<status>available</status>
			<tags>
				<tag>
					<id>0</id>
					<name>string</name>
				</tag>
			</tags>
		</Pet>

Если выбрать в выпадающем списке "Response content type" JSON, то в ответе вернется JSON вместо XML.

![JSON](https://github.com/Starkovden/Documenting_APIs/blob/master/1.%20Introduction%20to%20REST%20APIs/pics/13.png?raw=true)

6. "Petstore" - является действующим API, питомец фактически создан. Для забавы развернем конечную точку GET / pet / {petId}, нажимаем `Try it out`, вводим `id` питомца, который использовали в предыдущей операции, а затем выполняем запрос. В ответе видим имя питомца, которое совпадает с тем, что ввели в предыдущем примере.

<a name="otherTools"></a>
## Другие инструменты визуализации

<a name="customize"></a>
## Кастомизация Swagger UI

<a name="downsides"></a>
## Недостатки OpenAPI и Swagger UI

<a name="consolations"></a>
## Некоторые утешения

<a name="reading"></a>
## Ресурсы для дальнейшего чтения
