# Требования аутентификации и авторизации

Прежде чем пользователи смогут отправлять запросы с помощью API, им обычно необходимо зарегистрироваться для получения ключа API или изучить другие способы аутентификации запросов. API-интерфейсы различаются по способу аутентификации пользователей. Некоторые API требуют включения ключа API в заголовок запроса, в то время как другие API требуют тщательной защиты из-за необходимости защиты конфиденциальных данных, подтверждения личности и обеспечения того, чтобы запросы не были подделаны. В этом разделе мы изучим аутентификацию и авторизацию, а также то, на чем следует сосредоточиться в документации.

[Определяем термины](#terms)

[Последствия нехватки безопасности API](#noSecurity)

[Разные виды авторизации](#aothTypes)

- [API ключ](#apikey)
- [Basic Auth](#basicAuth)
- [HMAC (код авторизации сообщений на основе хэша)](#hmac)
- [OAuth 2.0](#auth2)

[Что документируется в разделе аутентификации](#docAuth)

[Образцы разделов авторизации](#samples)

- [SendGrid](#SendGrid)
- [Twitter](#Twitter)
- [Amazon Web Services](#Amazon)
- [Dropbox](#Dropbox)

[Практическое занятие: авторизация](#activity)

<a name="terms"></a>
## Определяем термины

Во-первых, давайте определимся с некоторыми ключевыми терминами:

- Аутентификация: подтверждение правильности личности
- Авторизация: разрешение определенного действия

API может аутентифицировать, но не разрешит делать определенный запрос.

![auth](https://github.com/Starkovden/Documenting_APIs/blob/master/6.%20Non-reference%20API%20topics/img/15.jpg?raw=true)
> аутентификация и авторизация

<a name="noSecurity"></a>
## Последствия нехватки безопасности API

Почему даже API-интерфейсы нуждаются в аутентификации? Для API, которые предназначены только для чтения, иногда пользователям не нужны ключи. Но большинство коммерческих API требуют авторизации в виде ключей API или других методов. Если нет никакой защиты API, пользователи могут совершать неограниченное количество запросов API без какой-либо регистрации. Разрешение неограниченных запросов усложнит модель дохода для вашего API.

Вдобавок, без аутентификации не было бы простого способа связать запросы с конкретными данными пользователя. И не было бы способа защиты от запросов от злонамеренных пользователей, которые могут удалить данные другого пользователя (например, путем удаления запросов DELETE для учетной записи другого пользователя).

Наконец, не получится отследить, кто использует API или какие конечные точки используются чаще всего. Очевидно, что разработчики API должны подумать о способах аутентификации и авторизации запросов к своим API.

В целом, аутентификация и авторизация с помощью API служат следующим целям:

- аутентификация запросов в API только для зарегистрированных пользователей;
- отслеживание, кто делает запросы;
- отслеживание использования API;
- блокировка или замедление пользователя, превышающего [пределы скорости](https://github.com/Starkovden/Documenting_APIs/blob/master/6.%20Non-reference%20API%20topics/6.6.%20Rate%20limiting%20and%20thresholds.md);
- применение разных уровней разрешений для разных пользователей.

<a name="aothTypes"></a>
## Разные виды авторизации

Существует несколько методов авторизации. Ниже рассмотрим несколько вариантов авторизации, которые встречаются чаще всего:

- [API ключ](#apikey)
- [Basic Auth](#basicAuth)
- [HMAC](#hmac)
- [OAuth 2.0](#auth2)

<a name="apikey"></a>
### API ключ

Большинство API требуют авторизации ключом API, чтобы использовать API. Ключ API представляет собой длинную строку, которую обычно включают либо в URL запроса, либо в заголовок запроса. Ключ API в основном служит способом идентификации лица, выполняющего запрос API (аутентифицируя для использования API). Ключ API также может быть связан с конкретным приложением, которое регистрируется.

![apikey](https://github.com/Starkovden/Documenting_APIs/blob/master/6.%20Non-reference%20API%20topics/img/16.jpg?raw=true)
> Ключи APK используют строку в свойстве заголовка для авторизации запросов

API могут дать как открытый, так и закрытый ключ. Открытый ключ обычно включается в запрос, в то время как закрытый ключ рассматривается скорее как пароль и используется только при обмене данными между серверами. На некоторых сайтах документации API, при заходе на сайт, ключ API автоматически заполняется в примере кода и API Explorer.

<a name="basicAuth"></a>
### Basic Auth

Другой тип авторизации называется Basic Auth. С помощью этого метода отправитель помещает пару `имя пользователя:пароль` в заголовок запроса. Имя пользователя и пароль кодируются с помощью Base64, который представляет собой метод кодирования, который преобразует имя пользователя и пароль в набор из 64 символов для обеспечения безопасной передачи. Вот пример Basic Auth в заголовке запроса:

    Authorization: Basic bG9sOnNlY3VyZQ==

API, использующие Basic Auth, также будут использовать HTTPS, что означает, что содержимое сообщения будет зашифровано в транспортном протоколе HTTP. (Без HTTPS людям было бы легко расшифровать зашифрованные данные)

Когда сервер API получает сообщение, он дешифрует сообщение и проверяет заголовок. После декодирования строки и анализа имени пользователя и пароля он решает, принять или отклонить запрос.

В Postman можно настроить базовую авторизацию, щелкнув вкладку **Authorization**, выбрав **Basic Auth** в раскрывающемся списке и введя **имя пользователя** и **пароль** справа от двоеточия в каждой строке. На вкладке Заголовки будет показана пара ключ-значение, выглядящая следующим образом:

    Authorization: Basic RnJlZDpteXBhc3N3b3Jk

Postman обрабатывает кодировку Base64 автоматически, при вводе имени пользователя и пароля с выбранным Basic Auth.

<a name="hmac"></a>
### HMAC (код авторизации сообщений на основе хэша

HMAC расшифровывается как Hash-based message authorization code - код авторизации сообщений на основе хэша и является более строгим типом аутентификации, более распространенным в финансовых API. В HMAC только отправитель, и получатель знают секретный ключ, который больше неизвестен никому. Отправитель создает сообщение на основе некоторых системных свойств (например, отметка времени запроса плюс идентификатор учетной записи).

Затем сообщение кодируется секретным ключом и проходит через алгоритм безопасного хеширования (SHA - secure hashing algorithm). (Хеш - это зашифрованная строка на основе алгоритма.) Результирующее значение, называемое сигнатурой, помещается в заголовок запроса.


Сервер API (получатель), получая запрос, принимает те же системные свойства (отметка времени запроса плюс идентификатор учетной записи) и использует секретный ключ (который известен только запрашивающей стороне и серверу API) и SHA для генерации одной и той же строки. Если строка соответствует подписи в заголовке запроса, запрос принимается. Если строки не совпадают, запрос отклоняется.

Вот диаграмма, отображающая процесс авторизации HMAC:

![HMAC](https://github.com/Starkovden/Documenting_APIs/blob/master/6.%20Non-reference%20API%20topics/img/17.jpg?raw=true)

Важным моментом является то, что секретный ключ (критический для восстановления хэша) известен только отправителю и получателю. Секретный ключ не включается в запрос. Безопасность HMAC используется, когда нужно убедиться, что запрос является подлинным и не может быть подделан.

<a name="auth2"></a>
### OAuth 2.0

Одним из популярных методов аутентификации и авторизации пользователей является OAuth 2.0. Такой подход опирается на сервер аутентификации для связи с сервером API для предоставления доступа. Понять, что используется метод OAuth 2.0, можно когда предлагается войти в систему при помощи сторонних сервисов, как Twitter, Google или Facebook.

![oauth2.0](https://github.com/Starkovden/Documenting_APIs/blob/master/6.%20Non-reference%20API%20topics/img/18.png?raw=true)
> окно входа в систему, использующую Oauth2.0

Существует несколько разновидностей OAuth, а именно «one-legged OAuth» и «three-legged OAuth». **One-legged OAuth** используется, когда нет конфиденциальных данных для защиты. Например, в том случае, если просто получаем общую информацию только для чтения.

**Three-legged OAuth** используется, когда нужно защитить конфиденциальные данные. В этом сценарии взаимодействуют три группы:

- сервер аутентификации;
- сервер API;
- пользователь или приложение.

Вот базовый процесс Oauth2.0:

![flow](https://github.com/Starkovden/Documenting_APIs/blob/master/6.%20Non-reference%20API%20topics/img/19.jpg?raw=true)

Сначала пользовательское приложение отправляет ключ приложения и секретные данные на страницу входа в систему на сервере аутентификации. Если аутентификация пройдена, сервер аутентификации возвращает пользователю токен доступа (авторизации).

Токен доступа (авторизации) упакован в параметр запроса в перенаправлении ответа (302) на запрос. Перенаправление направляет запрос пользователя обратно на сервер ресурсов (сервер API).

Затем пользователь отправляет запрос на сервер ресурсов (сервер API). Токен доступа (авторизации) добавляется в заголовок запроса API со словом `Bearer`, за которым следует строка токена. Сервер API проверяет токен доступа (авторизации) в запросе пользователя и решает, аутентифицировать ли пользователя.

Токены доступа (авторизации) не только обеспечивают аутентификацию для запрашивающей стороны, но и определяют права пользователя на использование API. Кроме того, токены доступа (авторизации) обычно истекают через некоторое время и требуют от пользователя повторного входа в систему. Для получения дополнительной информации об OAuth 2.0 можно посмотреть ресурсы:

- [Learn API Technical Writing 2: REST for Writers (Udemy)](https://www.udemy.com/learn-api-technical-writing-2-rest-for-writers/), Питера Грюнбаума;
- [OAuth simplified](https://aaronparecki.com/oauth-2-simplified/), Аарона Парецки.

<a name="docAuth"></a>
## Что документируется в разделе аутентификации

В документации API не нужно подробно объяснять внешним пользователям, как работает аутентификация. Отсутствие объяснений внутренних процессов аутентификации, является лучшей практикой, поскольку хакерам будет сложнее злоупотреблять API.

Тем не менее нужно объяснить необходимую информацию:

- как получить API ключ;
- как пройти аутентификацию запроса;
- сообщения об ошибках, связанных с неверной аутентификацией;
- чувствительность информации аутентификации;
- период действия токена доступа (авторизации).

Если есть открытый и закрытый ключи, нужно объяснить, где следует использовать каждый ключ, и отметить, что закрытые ключи не должны использоваться совместно. Если разные уровни лицензий предоставляют разный доступ к вызовам API, эти уровни лицензирования должны быть явно указаны в разделе авторизации или в другом месте.

Поскольку раздел API ключей важен, и нужен разработчикам до того, как они начнут использовать API, этот раздел должен быть в начале руководства.

<a name="samples"></a>
## Образцы разделов авторизации

Ниже приведены несколько примеров разделов авторизации в документации API.

<a name="SendGrid"></a>
### SendGrid

![SendGrid](https://github.com/Starkovden/Documenting_APIs/blob/master/6.%20Non-reference%20API%20topics/img/20.png?raw=true)
> API ключ SendGrid

SendGrid предлагает подробное объяснение ключей API, начиная с основ, поясняя: «Что такое ключи API?». Контекстно раздел ключей API появляется вместе с другими разделами по управлению учетными записями.

<a name="Twitter"></a>
### Twitter

![Twitter](https://github.com/Starkovden/Documenting_APIs/blob/master/6.%20Non-reference%20API%20topics/img/21.png?raw=true)
> авторизация Twitter

В Twitter подробный пример оправдан и предоставлен, поскольку требования к авторизации OAuth 2.0 немного сложнее.

<a name="Amazon"></a>
### Amazon Web Services

![amazon](https://github.com/Starkovden/Documenting_APIs/blob/master/6.%20Non-reference%20API%20topics/img/22.png?raw=true)
> авторизация амазон

Amazon использует HMAC. Процесс достаточно сложный, чтобы включить полноценную диаграмму, показать шаги, которые должны выполнить пользователи.

<a name="Dropbox"></a>
### Dropbox

![Dropbox](https://github.com/Starkovden/Documenting_APIs/blob/master/6.%20Non-reference%20API%20topics/img/23.png?raw=true)
> Авторизация в Dropbox

Как и Twitter, Dropbox также использует OAuth 2.0. Их документация включает в себя не одну, а две диаграммы и подробное объяснение процесса.

<a name="activity"></a>
## ![idea](https://github.com/Starkovden/Documenting_APIs/blob/master/1.%20Introduction%20to%20REST%20APIs/pics/1.jpg?raw=true) Практическое занятие: Авторизация

В своем [найденном опен-сорс проекте](https://github.com/Starkovden/Documenting_APIs/blob/master/3.%20Documenting%20API%20endpoints/3.9.%20Activity%20Find%20an%20open%20source%20project.md#%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%B7%D0%B0%D0%BD%D1%8F%D1%82%D0%B8%D0%B5-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA-open-source-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0) найдем информацию об авторизации для запросов к API. Ответьте на следующие вопросы:

- Какого рода авторизация требуется для отправки запросов к API?
- Существуют ли разные уровни доступа в рамках авторизации (например, платные и бесплатные), которые определяют, сколько запросов можно сделать или какие типы информации можно получить?
- Можно ли вы получить ключ API или какой-либо другой метод авторизации, необходимый для выполнения тестовых вызовов API?
- Как информация об авторизации интегрируется в раздел "Начало работы"?
